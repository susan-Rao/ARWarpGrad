"""Based on code for WarpGrad:https://github.com/flennerhag/warpgrad.We modify the code to provide ARWarpGrad."""import randomimport osfrom os.path import joinimport torchfrom torch.utils.data import DataLoader as DLfrom torchvision.datasets.omniglot import Omniglot as _Omniglotfrom torchvision.datasets.imagenet import ImageNet as _ImageNetfrom torchvision.datasets.utils import list_dir, list_filesfrom torchvision import transformsfrom data_sampler import RandomSamplerTRAIN = 20VAL = 10TEST = 10HOLD_OUT = 5DEFAULT_TRANSFORM = transforms.Compose([    transforms.Resize((28, 28)),    transforms.ToTensor(),])class DataLoader(object):    # folder = "rsz"    # target_folder = "mini-imagenet"    # flag = False    folder = "omniglot-py"    target_folder = "images_resized"    flag = True    def __init__(self, root="./data", num_pretrain_alphabets=1,                 num_classes=None,num_sample=None,num_query=None, transform=DEFAULT_TRANSFORM,                 seed=1, **kwargs):        self.root = root        self.num_pretrain_alphabets = num_pretrain_alphabets        self.transform = transform        self.seed = seed        self.kwargs = kwargs        data_path = join(join(os.path.expanduser(self.root), self.folder),                    self.target_folder)        if self.flag:            # for omniglot            alphabets = list_dir(data_path)            if num_classes:                alphabets = [a for a in alphabets                             if len(list_dir(join(data_path, a))) >= num_classes]                assert self.num_pretrain_alphabets + TEST < len(alphabets), \                    'cannot create test set'            random.seed(self.seed)            random.shuffle(alphabets)            trs = self.num_pretrain_alphabets            tes = trs + TEST            train = alphabets[:trs]            test = alphabets[trs:tes]            val = alphabets[tes+1:tes+VAL]            trainset = [SubOmniglot(root, [t], num_classes, num_sample, num_query,                                    transform=transform) for t in train]            testset = [SubOmniglot(root, [v], num_classes, num_sample, num_query,                                   transform=transform) for v in test]            valset = [SubOmniglot(root, [v], num_classes, num_sample, num_query,                                  transform=transform) for v in val]            self.alphabets = alphabets            self.alphabets_train = train            self.alphabets_test = test            self.alphabets_val = val            self.data_train = trainset            self.data_test = testset            self.data_val = valset        else:            # for imagent            train = [os.path.join(data_path, 'train', family) \                             for family in os.listdir(os.path.join(data_path, 'train')) \                             if os.path.isdir((os.path.join(data_path, 'train', family)))]            val = [os.path.join(data_path, 'val', family) \                           for family in os.listdir(os.path.join(data_path, 'val')) \                           if os.path.isdir((os.path.join(data_path, 'val', family)))]            test = [os.path.join(data_path, 'test', family) \                            for family in os.listdir(os.path.join(data_path, 'test')) \                            if os.path.isdir((os.path.join(data_path, 'test', family)))]            trainset = [Subminiimagenet(train, num_classes, num_sample, num_query,transform=transform)]            testset = [Subminiimagenet(test, num_classes, num_sample, num_query,transform=transform)]            valset = [Subminiimagenet(val, num_classes, num_sample, num_query,transform=transform)]            alphabets = train + val + test            self.data_train = trainset[0]            self.data_test = testset[0]            self.data_val = valset[0]        #share part        self.alphabets = alphabets        self.alphabets_train = train        self.alphabets_test = test        self.alphabets_val = val    def get_loader(self, task, batch_size, iterations):        return DL(task,batch_size,sampler=RandomSampler(task, iterations, batch_size),**self.kwargs)    def train(self, meta_batch_size, batch_size, iterations, return_idx=False):        n_tasks = len(self.data_train)        if n_tasks == 1:            tasks = zip([0] * meta_batch_size,                        self.data_train * meta_batch_size)        else:            tasks = []            task_ids = list(range(n_tasks))            while True:                random.shuffle(task_ids)                tasks.extend([(i, self.data_train[i]) for i in task_ids])                if len(tasks) >= meta_batch_size:                    break            tasks = tasks[:meta_batch_size]        task_ids, task_data = zip(*tasks)        task_data = [self.get_loader(t, batch_size, iterations)                     for t in task_data]        if return_idx:            return list(zip(task_ids, task_data))        return task_data    def val(self, batch_size, iterations, return_idx=False):        n = len(self.data_train)        tsk = [i+n for i in range(len(self.data_val))]        tasks = [self.get_loader(d, batch_size, iterations)                 for d in self.data_val]        if return_idx:            return list(zip(tsk, tasks))        return tasks    def test(self, batch_size, iterations, return_idx=False):        n = len(self.data_train) + len(self.data_val)        tsk = [i+n for i in range(len(self.data_test))]        tasks = [self.get_loader(d, batch_size, iterations)                 for d in self.data_test]        if return_idx:            return list(zip(tsk, tasks))        return tasksclass SubOmniglot(_Omniglot):    folder = "omniglot-py"    target_folder = "images_resized"    def __init__(self, root, alphabets, num_classes=None, num_sample=None, num_query=None,                 transform=None, seed=None):        self.root = join(os.path.expanduser(root), self.folder)        self.alphabets = alphabets        self.num_classes = num_classes        self.num_query = num_query        self.num_sample = num_sample        self.transform = transform        self.target_transform = None        self.seed = seed        self.target_folder = join(self.root, self.target_folder)        self._alphabets = [a for a in list_dir(self.target_folder)                           if a in self.alphabets]        self._characters = sum(            [[join(a, c) for c in list_dir(join(self.target_folder, a))]             for a in self._alphabets], [])        if seed:            random.seed(seed)        random.shuffle(self._characters)        if self.num_classes:            self._characters = self._characters[:num_classes]        self._character_images = [            [(image, idx) for image in             list_files(join(self.target_folder, character), '.png')]            for idx, character in enumerate(self._characters)        ]        self._train_character_images = []        self._val_character_images = []        for idx, character in enumerate(self._characters):            train_characters = []            val_characters = []            for img_count, image in enumerate(                    list_files(join(self.target_folder, character), '.png')):                if num_query and img_count < num_query:                    val_characters.append((image, idx))                else:                    if num_sample and img_count < (num_query+num_sample):                        train_characters.append((image, idx))            self._train_character_images.append(train_characters)            self._val_character_images.append(val_characters)        self._flat_train_character_images = sum(            self._train_character_images, [])        self._flat_val_character_images = sum(            self._val_character_images, [])        self._train = True        self._set_images()    def train(self):        """Train mode"""        self._train = True        self._set_images()    def eval(self):        """Eval mode"""        self._train = False        self._set_images()    def _set_images(self):        """Set images"""        if self._train:            self._flat_character_images = self._flat_train_character_images        else:            self._flat_character_images = self._flat_val_character_imagesclass Subminiimagenet(_ImageNet):    def __init__(self, target_forder, num_classes=None, num_sample=None, num_query=None,transform=None):        self.target_folder = target_forder        self.num_classes = num_classes        self.num_query = num_query        self.num_sample = num_sample        self.transform = transform        self.target_transform = None        if self.num_classes:            self._characters = self.target_folder[:num_classes]        self._character_images = [            [(image, idx) for image in             list_files(character, '.jpg')]            for idx, character in enumerate(self._characters)        ]        self._train_character_images = []        self._val_character_images = []        for idx, character in enumerate(self._characters):            train_characters = []            val_characters = []            for img_count, image in enumerate(                    list_files(character, '.jpg')):                if num_query and img_count < num_query:                    val_characters.append((image, idx))                else:                    if num_sample and img_count < (num_query+num_sample):                        train_characters.append((image, idx))            self._train_character_images.append(train_characters)            self._val_character_images.append(val_characters)        self._flat_train_character_images = sum(            self._train_character_images, [])        self._flat_val_character_images = sum(            self._val_character_images, [])        self._train = True        self._set_images()    def train(self):        """Train mode"""        self._train = True        self._set_images()    def eval(self):        """Eval mode"""        self._train = False        self._set_images()    def _set_images(self):        """Set images"""        if self._train:            self._flat_character_images = self._flat_train_character_images        else:            self._flat_character_images = self._flat_val_character_images